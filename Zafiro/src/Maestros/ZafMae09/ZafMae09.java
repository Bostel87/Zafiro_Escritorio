/*
 * ZafMae09.java
 *
 * Created on 25 de septiembre de 2007, 12:19 AM
 */
package Maestros.ZafMae09;
import Librerias.ZafParSis.ZafParSis;
import Librerias.ZafUtil.ZafUtil;
import Librerias.ZafTblUti.ZafTblFilCab.ZafTblFilCab;
import Librerias.ZafTblUti.ZafTblMod.ZafTblMod;
import Librerias.ZafTblUti.ZafTblEdi.ZafTblEdi;
import Librerias.ZafTblUti.ZafTblCelRenLbl.ZafTblCelRenLbl;
import Librerias.ZafTblUti.ZafTblCelRenChk.ZafTblCelRenChk;
import Librerias.ZafTblUti.ZafTblCelEdiTxt.ZafTblCelEdiTxt;
import Librerias.ZafTblUti.ZafTblCelEdiChk.ZafTblCelEdiChk;
import Librerias.ZafTblUti.ZafTblPopMnu.ZafTblPopMnu;
import Librerias.ZafToolBar.ZafToolBar;
import Librerias.ZafRptSis.ZafRptSis;
import java.sql.Connection;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Vector;
import java.util.ArrayList;
import java.math.BigDecimal;

/**
 *
 * @author  Eddye Lino
 */
public class ZafMae09 extends javax.swing.JInternalFrame 
{
    //Constantes: Columnas del JTable.
    static final int INT_TBL_DAT_LIN=0;                         //Línea
    static final int INT_TBL_DAT_DIA_CRE=1;                     //Días de crédito.
    static final int INT_TBL_DAT_CHK_SOP=2;                     //Necesario soporte.

    //Variables generales.
    private ZafParSis objParSis;
    private ZafUtil objUti;
    private ZafTblFilCab objTblFilCab;
    private ZafTblMod objTblMod;
    private ZafTblEdi objTblEdi;                                //Editor: Editor del JTable.
    private ZafThreadGUI objThrGUI;
    private ZafTblCelRenLbl objTblCelRenLbl;                    //Render: Presentar JLabel en JTable.
    private ZafTblCelRenChk objTblCelRenChk;                    //Render: Presentar JCheckBox en JTable.
    private ZafTblCelEdiTxt objTblCelEdiTxt;                    //Editor: JTextField en celda.
    private ZafTblCelEdiChk objTblCelEdiChk;                    //Editor: JCheckBox en celda.
    private ZafMouMotAda objMouMotAda;                          //ToolTipText en TableHeader.
    private ZafTblPopMnu objTblPopMnu;                          //PopupMenu: Establecer PeopuMenú en JTable.
    private MiToolBar objTooBar;                                //Barra de botones.
    private ZafRptSis objRptSis;                                //Reportes del Sistema.
    private Connection con, conCab;
    private Statement stm, stmCab;
    private ResultSet rst, rstCab;
    private String strSQL, strAux, strSQLCon;
    private Vector vecEstReg;
    private Vector vecDat, vecCab, vecReg;
    private Vector vecAux;
    private boolean blnCon;                                     //true: Continua la ejecución del hilo.
    private boolean blnHayCam;                                  //Determina si hay cambios en el formulario.
    private ZafDocLis objDocLis;
    private String strNomForPag;                                //Contenido del campo al obtener el foco.
    private String strNumPag;                                   //Contenido del campo al obtener el foco.
    private java.util.Date datFecAux;                           //Auxiliar: Para almacenar fechas.
    //Variables de la clase.
    private String strEstRegRep;                                //Estado del registro a replicar.
    
    /** Crea una nueva instancia de la clase ZafMae27. */
    public ZafMae09(ZafParSis obj)
    {
        try
        {
            initComponents();
            //Inicializar objetos.
            objParSis=(ZafParSis)obj.clone();
        }
        catch (CloneNotSupportedException e)
        {
            this.setTitle(this.getTitle() + " [ERROR]");
        }
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        bgrTipForPag = new javax.swing.ButtonGroup();
        panFrm = new javax.swing.JPanel();
        lblTit = new javax.swing.JLabel();
        tabFrm = new javax.swing.JTabbedPane();
        panGen = new javax.swing.JPanel();
        panGenCab = new javax.swing.JPanel();
        lblNom = new javax.swing.JLabel();
        lblCod = new javax.swing.JLabel();
        lblNumPag = new javax.swing.JLabel();
        lblTipForPag = new javax.swing.JLabel();
        lblObs1 = new javax.swing.JLabel();
        lblEstReg = new javax.swing.JLabel();
        optTipForPagNeg = new javax.swing.JRadioButton();
        optTipForPagCon = new javax.swing.JRadioButton();
        optTipForPagChq = new javax.swing.JRadioButton();
        optTipForPagCre = new javax.swing.JRadioButton();
        spnObs1 = new javax.swing.JScrollPane();
        txaObs1 = new javax.swing.JTextArea();
        cboEstReg = new javax.swing.JComboBox();
        txtNom = new javax.swing.JTextField();
        txtCod = new javax.swing.JTextField();
        spiNumPag = new javax.swing.JSpinner();
        panGenDet = new javax.swing.JPanel();
        spnDat = new javax.swing.JScrollPane();
        tblDat = new javax.swing.JTable();
        panBar = new javax.swing.JPanel();

        setClosable(true);
        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setIconifiable(true);
        setMaximizable(true);
        setResizable(true);
        setTitle("Título de la ventana");
        addInternalFrameListener(new javax.swing.event.InternalFrameListener() {
            public void internalFrameActivated(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameClosed(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameClosing(javax.swing.event.InternalFrameEvent evt) {
                exitForm(evt);
            }
            public void internalFrameDeactivated(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameDeiconified(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameIconified(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameOpened(javax.swing.event.InternalFrameEvent evt) {
                formInternalFrameOpened(evt);
            }
        });
        getContentPane().setLayout(new java.awt.GridLayout(1, 0));

        panFrm.setLayout(new java.awt.BorderLayout());

        lblTit.setFont(new java.awt.Font("MS Sans Serif", 1, 14));
        lblTit.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblTit.setText("Título");
        panFrm.add(lblTit, java.awt.BorderLayout.NORTH);

        panGen.setLayout(new java.awt.BorderLayout());

        panGenCab.setPreferredSize(new java.awt.Dimension(0, 144));
        panGenCab.setLayout(null);

        lblNom.setText("Nombre:");
        panGenCab.add(lblNom);
        lblNom.setBounds(0, 24, 100, 20);

        lblCod.setText("Código:");
        panGenCab.add(lblCod);
        lblCod.setBounds(0, 4, 100, 20);

        lblNumPag.setText("Número de pagos:");
        lblNumPag.setToolTipText("Número de pagos");
        panGenCab.add(lblNumPag);
        lblNumPag.setBounds(0, 44, 100, 20);

        lblTipForPag.setText("Tipo de forma de pago:");
        lblTipForPag.setToolTipText("Tipo de forma de pago");
        panGenCab.add(lblTipForPag);
        lblTipForPag.setBounds(0, 64, 100, 20);

        lblObs1.setText("Observación1:");
        panGenCab.add(lblObs1);
        lblObs1.setBounds(0, 84, 100, 20);

        lblEstReg.setText("Estado del registro:");
        lblEstReg.setToolTipText("Estado del registro");
        panGenCab.add(lblEstReg);
        lblEstReg.setBounds(0, 124, 100, 20);

        bgrTipForPag.add(optTipForPagNeg);
        optTipForPagNeg.setText("Negociación");
        panGenCab.add(optTipForPagNeg);
        optTipForPagNeg.setBounds(100, 64, 116, 20);

        bgrTipForPag.add(optTipForPagCon);
        optTipForPagCon.setSelected(true);
        optTipForPagCon.setText("Contado");
        panGenCab.add(optTipForPagCon);
        optTipForPagCon.setBounds(216, 64, 116, 20);

        bgrTipForPag.add(optTipForPagChq);
        optTipForPagChq.setText("Cheque");
        panGenCab.add(optTipForPagChq);
        optTipForPagChq.setBounds(332, 64, 116, 20);

        bgrTipForPag.add(optTipForPagCre);
        optTipForPagCre.setText("Crédito");
        panGenCab.add(optTipForPagCre);
        optTipForPagCre.setBounds(448, 64, 116, 20);

        spnObs1.setViewportView(txaObs1);

        panGenCab.add(spnObs1);
        spnObs1.setBounds(100, 84, 464, 40);
        panGenCab.add(cboEstReg);
        cboEstReg.setBounds(100, 124, 180, 20);

        txtNom.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                txtNomFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                txtNomFocusLost(evt);
            }
        });
        panGenCab.add(txtNom);
        txtNom.setBounds(100, 24, 464, 20);

        txtCod.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        panGenCab.add(txtCod);
        txtCod.setBounds(100, 4, 100, 20);

        spiNumPag.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                spiNumPagStateChanged(evt);
            }
        });
        panGenCab.add(spiNumPag);
        spiNumPag.setBounds(100, 44, 100, 20);

        panGen.add(panGenCab, java.awt.BorderLayout.NORTH);

        panGenDet.setLayout(new java.awt.BorderLayout());

        tblDat.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        spnDat.setViewportView(tblDat);

        panGenDet.add(spnDat, java.awt.BorderLayout.CENTER);

        panGen.add(panGenDet, java.awt.BorderLayout.CENTER);

        tabFrm.addTab("General", panGen);

        panFrm.add(tabFrm, java.awt.BorderLayout.CENTER);

        panBar.setLayout(new java.awt.BorderLayout());
        panFrm.add(panBar, java.awt.BorderLayout.SOUTH);

        getContentPane().add(panFrm);

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-600)/2, (screenSize.height-400)/2, 600, 400);
    }// </editor-fold>//GEN-END:initComponents

    private void txtNomFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_txtNomFocusLost
        if (txtNom.isEditable())
        {
            //Validar el contenido de la celda sólo si ha cambiado.
            if (!txtNom.getText().equalsIgnoreCase(strNomForPag))
            {
                if (txtNom.getText().equals(""))
                {
                    optTipForPagCon.setSelected(true);
                }
                else
                {
                    //Seleccionar el "Tipo de forma de pago" de acuerdo al inicio del nombre de la forma de pago.
                    strAux=txtNom.getText().toLowerCase();
                    if (strAux.startsWith("contado"))
                        optTipForPagCon.setSelected(true);
                    else if (strAux.startsWith("cheque"))
                        optTipForPagChq.setSelected(true);
                    else if ( strAux.startsWith("crédito") || strAux.startsWith("credito") )
                        optTipForPagCre.setSelected(true);
                    else
                        optTipForPagNeg.setSelected(true);
                }
            }
            else
                txtNom.setText(strNomForPag);
        }
    }//GEN-LAST:event_txtNomFocusLost

    private void txtNomFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_txtNomFocusGained
        strNomForPag=txtNom.getText();
        txtNom.selectAll();
    }//GEN-LAST:event_txtNomFocusGained

    private void spiNumPagStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_spiNumPagStateChanged
        try
        {
            objTblMod.setRowCount(Integer.parseInt(spiNumPag.getValue().toString()));
        }
        catch (NumberFormatException e)
        {
            objUti.mostrarMsgErr_F1(this, e);
        }
    }//GEN-LAST:event_spiNumPagStateChanged

    private void formInternalFrameOpened(javax.swing.event.InternalFrameEvent evt) {//GEN-FIRST:event_formInternalFrameOpened
        configurarFrm();
        agregarDocLis();
    }//GEN-LAST:event_formInternalFrameOpened

    /** Cerrar la aplicación. */
    private void exitForm(javax.swing.event.InternalFrameEvent evt) {//GEN-FIRST:event_exitForm
        String strTit, strMsg;
        try
        {
            javax.swing.JOptionPane oppMsg=new javax.swing.JOptionPane();
            strTit="Mensaje del sistema Zafiro";
            strMsg="¿Está seguro que desea cerrar este programa?";
            if (oppMsg.showConfirmDialog(this,strMsg,strTit,javax.swing.JOptionPane.YES_NO_OPTION,javax.swing.JOptionPane.QUESTION_MESSAGE)==javax.swing.JOptionPane.YES_OPTION)
            {
                //Cerrar la conexión si está abierta.
                if (rstCab!=null)
                {
                    rstCab.close();
                    stmCab.close();
                    conCab.close();
                    rstCab=null;
                    stmCab=null;
                    conCab=null;
                }
                dispose();
            }
        }
        catch (java.sql.SQLException e)
        {
            dispose();
        }
    }//GEN-LAST:event_exitForm

    /** Cerrar la aplicación. */
    private void exitForm() 
    {
        dispose();
    }    
        
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup bgrTipForPag;
    private javax.swing.JComboBox cboEstReg;
    private javax.swing.JLabel lblCod;
    private javax.swing.JLabel lblEstReg;
    private javax.swing.JLabel lblNom;
    private javax.swing.JLabel lblNumPag;
    private javax.swing.JLabel lblObs1;
    private javax.swing.JLabel lblTipForPag;
    private javax.swing.JLabel lblTit;
    private javax.swing.JRadioButton optTipForPagChq;
    private javax.swing.JRadioButton optTipForPagCon;
    private javax.swing.JRadioButton optTipForPagCre;
    private javax.swing.JRadioButton optTipForPagNeg;
    private javax.swing.JPanel panBar;
    private javax.swing.JPanel panFrm;
    private javax.swing.JPanel panGen;
    private javax.swing.JPanel panGenCab;
    private javax.swing.JPanel panGenDet;
    private javax.swing.JSpinner spiNumPag;
    private javax.swing.JScrollPane spnDat;
    private javax.swing.JScrollPane spnObs1;
    private javax.swing.JTabbedPane tabFrm;
    private javax.swing.JTable tblDat;
    private javax.swing.JTextArea txaObs1;
    private javax.swing.JTextField txtCod;
    private javax.swing.JTextField txtNom;
    // End of variables declaration//GEN-END:variables

    /** Configurar el formulario. */
    private boolean configurarFrm()
    {
        boolean blnRes=true;
        try
        {
            //Inicializar objetos.
            objUti=new ZafUtil();
            objTooBar=new MiToolBar(this);
            objTooBar.setVisibleEliminar(false);
            objTooBar.setVisibleAnular(false);
            objDocLis=new ZafDocLis();
            panBar.add(objTooBar);
            objRptSis=new ZafRptSis(javax.swing.JOptionPane.getFrameForComponent(this), true, objParSis);
            this.setTitle(objParSis.getNombreMenu() + " v0.4");
            lblTit.setText(objParSis.getNombreMenu());
            //Configurar el JSpinner:
            spiNumPag.setModel(new javax.swing.SpinnerNumberModel(1, 1, 100, 1));
            spiNumPag.setEditor(new javax.swing.JSpinner.NumberEditor(spiNumPag, "#"));
            ((javax.swing.JSpinner.DefaultEditor)spiNumPag.getEditor()).getTextField().addFocusListener(new java.awt.event.FocusAdapter() {
                public void focusGained(java.awt.event.FocusEvent evt) {
                    if (spiNumPag.getEditor() instanceof javax.swing.JSpinner.DefaultEditor)
                    {
                        //Fue necesario utilizar "invokeLater" porque si sólo se ponía la línea que esta ubicada en el "run" no aparecía seleccionado el texto cuando el JSpinner ganaba el foco.
                        javax.swing.SwingUtilities.invokeLater(new Runnable()
                        {
                            public void run()
                            {
                                ((javax.swing.JSpinner.DefaultEditor)spiNumPag.getEditor()).getTextField().selectAll();
                            }
                        });
                    }
                }
                public void focusLost(java.awt.event.FocusEvent evt) {
                    //Validar que el valor digitado sea válido. Si no es válido se genera una excepción. Si se genera una excepción lo que se hace
                    //es establecer en el editor del JSpinner el valor que tenía antes de que se cambiara el valor por un valor no válido.
                    try
                    {
                        spiNumPag.commitEdit();
                    }
                    catch (java.text.ParseException e)
                    {
                        if (spiNumPag.getEditor() instanceof javax.swing.JSpinner.DefaultEditor)
                        {
                            ((javax.swing.JSpinner.DefaultEditor)spiNumPag.getEditor()).getTextField().setValue(spiNumPag.getValue());
                        }
                    }
                    objTblMod.setRowCount(Integer.parseInt(((javax.swing.JSpinner.DefaultEditor)spiNumPag.getEditor()).getTextField().getText()));
                }
            });
            //JComboBox: Configurar.
            vecEstReg=new Vector();
            vecEstReg.add("A");
            vecEstReg.add("I");
            cboEstReg.addItem("Activo");
            cboEstReg.addItem("Inactivo");
            //Configurar objetos.
            txtCod.setBackground(objParSis.getColorCamposSistema());
            txtNom.setBackground(objParSis.getColorCamposObligatorios());
            //Configurar los JTables.
            configurarTblDat();
        }
        catch(Exception e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        return blnRes;
    }

    /**
     * Esta función configura el JTable "tblDat".
     * @return true: Si se pudo configurar el JTable.
     * <BR>false: En el caso contrario.
     */
    private boolean configurarTblDat()
    {
        boolean blnRes=true;
        try
        {
            //Configurar JTable: Establecer el modelo.
            vecDat=new Vector();    //Almacena los datos
            vecCab=new Vector(3);   //Almacena las cabeceras
            vecCab.clear();
            vecCab.add(INT_TBL_DAT_LIN,"");
            vecCab.add(INT_TBL_DAT_DIA_CRE,"Días de crédito");
            vecCab.add(INT_TBL_DAT_CHK_SOP,"¿Es necesario soporte?");
            //Configurar JTable: Establecer el modelo de la tabla.
            objTblMod=new ZafTblMod();
            objTblMod.setHeader(vecCab);
            //Configurar ZafTblMod: Establecer el tipo de dato de las columnas.
            objTblMod.setColumnDataType(INT_TBL_DAT_DIA_CRE, objTblMod.INT_COL_INT, new Integer(0), null);
            //Configurar JTable: Establecer el modelo de la tabla.
            tblDat.setModel(objTblMod);
            //Configurar JTable: Establecer tipo de selección.
            tblDat.setRowSelectionAllowed(true);
            tblDat.setSelectionMode(javax.swing.ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
            //Configurar JTable: Establecer el menú de contexto.
            objTblPopMnu=new ZafTblPopMnu(tblDat);
            //Configurar JTable: Establecer el tipo de redimensionamiento de las columnas.
            tblDat.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
            //Configurar JTable: Establecer el ancho de las columnas.
            javax.swing.table.TableColumnModel tcmAux=tblDat.getColumnModel();
            tcmAux.getColumn(INT_TBL_DAT_LIN).setPreferredWidth(30);
            tcmAux.getColumn(INT_TBL_DAT_DIA_CRE).setPreferredWidth(200);
            tcmAux.getColumn(INT_TBL_DAT_CHK_SOP).setPreferredWidth(200);
            //Configurar JTable: Establecer las columnas que no se pueden redimensionar.
//            tcmAux.getColumn(INT_TBL_DAT_CHK).setResizable(false);
            //Configurar JTable: Establecer el tipo de reordenamiento de columnas.
            tblDat.getTableHeader().setReorderingAllowed(false);
            //Configurar JTable: Ocultar columnas del sistema.
//            tcmAux.getColumn(INT_TBL_DAT_COD_SIS).setWidth(0);
//            tcmAux.getColumn(INT_TBL_DAT_COD_SIS).setMaxWidth(0);
//            tcmAux.getColumn(INT_TBL_DAT_COD_SIS).setMinWidth(0);
//            tcmAux.getColumn(INT_TBL_DAT_COD_SIS).setPreferredWidth(0);
//            tcmAux.getColumn(INT_TBL_DAT_COD_SIS).setResizable(false);
            //Configurar JTable: Mostrar ToolTipText en la cabecera de las columnas.
            objMouMotAda=new ZafMouMotAda();
            tblDat.getTableHeader().addMouseMotionListener(objMouMotAda);
            //Configurar JTable: Establecer columnas editables.
            vecAux=new Vector();
            vecAux.add("" + INT_TBL_DAT_DIA_CRE);
            vecAux.add("" + INT_TBL_DAT_CHK_SOP);
            objTblMod.setColumnasEditables(vecAux);
            vecAux=null;
            //Configurar JTable: Editor de la tabla.
            objTblEdi=new ZafTblEdi(tblDat);
            //Configurar JTable: Establecer la fila de cabecera.
            objTblFilCab=new ZafTblFilCab(tblDat);
            tcmAux.getColumn(INT_TBL_DAT_LIN).setCellRenderer(objTblFilCab);
            //Configurar JTable: Renderizar celdas.
            objTblCelRenChk=new ZafTblCelRenChk();
            tcmAux.getColumn(INT_TBL_DAT_CHK_SOP).setCellRenderer(objTblCelRenChk);
            objTblCelRenChk=null;
            
            objTblCelRenLbl=new ZafTblCelRenLbl();
            objTblCelRenLbl.setHorizontalAlignment(javax.swing.JLabel.RIGHT);
            tcmAux.getColumn(INT_TBL_DAT_DIA_CRE).setCellRenderer(objTblCelRenLbl);
            objTblCelRenLbl=null;
            //Configurar JTable: Editor de celdas.
            objTblCelEdiTxt=new ZafTblCelEdiTxt(tblDat);
            tcmAux.getColumn(INT_TBL_DAT_DIA_CRE).setCellEditor(objTblCelEdiTxt);
            objTblCelEdiTxt=null;
            
            objTblCelEdiChk=new ZafTblCelEdiChk(tblDat);
            tcmAux.getColumn(INT_TBL_DAT_CHK_SOP).setCellEditor(objTblCelEdiChk);
            objTblCelEdiChk=null;
            
            //Libero los objetos auxiliares.
            tcmAux=null;
        }
        catch(Exception e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        return blnRes;
    }
    
    /**
     * Esta clase crea la barra de herramientas para el sistema. Dicha barra de herramientas
     * contiene los botones que realizan las diferentes operaciones del sistema. Es decir,
     * insertar, consultar, modificar, eliminar, etc. Además de los botones de navegación
     * que permiten desplazarse al primero, anterior, siguiente y último registro.
     */
    private class MiToolBar extends ZafToolBar
    {
        public MiToolBar(javax.swing.JInternalFrame ifrFrm)
        {
            super(ifrFrm, objParSis);
        }

        public boolean anular()
        {
            if (!anularReg())
                return false;
            objTooBar.setEstadoRegistro("Anulado");
            blnHayCam=false;
            return true;
        }

        public void clickAceptar()
        {
            
        }

        public void clickAnterior() //OK
        {
            try
            {
                if (!rstCab.isFirst())
                {
                    if (blnHayCam || objTblMod.isDataModelChanged())
                    {
                        if (isRegPro())
                        {
                            rstCab.previous();
                            cargarReg();
                        }
                    }
                    else
                    {
                        rstCab.previous();
                        cargarReg();
                    }
                }
            }
            catch (java.sql.SQLException e)
            {
                objUti.mostrarMsgErr_F1(this, e);
            }
            catch (Exception e)
            {
                objUti.mostrarMsgErr_F1(this, e);
            }
        }

        public void clickAnular()
        {
            
        }

        public void clickCancelar()
        {

        }

        public void clickConsultar() //OK
        {
            switch (objTooBar.getEstado())
            {
                case 'c':
                case 'x':
                case 'y':
                case 'z':
                    txtCod.requestFocus();
                    break;
                case 'j':
                    break;
            }
            //Inicializar las variables que indican cambios.
            blnHayCam=false;
        }

        public void clickEliminar()
        {
            
        }

        public void clickFin() //OK
        {
            try
            {
                if (!rstCab.isLast())
                {
                    if (blnHayCam || objTblMod.isDataModelChanged())
                    {
                        if (isRegPro())
                        {
                            rstCab.last();
                            cargarReg();
                        }
                    }
                    else
                    {
                        rstCab.last();
                        cargarReg();
                    }
                }
            }
            catch (java.sql.SQLException e)
            {
                objUti.mostrarMsgErr_F1(this, e);
            }
            catch (Exception e)
            {
                objUti.mostrarMsgErr_F1(this, e);
            }
        }

        public void clickImprimir()
        {
            
        }

        public void clickInicio() //OK
        {
            try
            {
                if (!rstCab.isFirst())
                {
                    if (blnHayCam || objTblMod.isDataModelChanged())
                    {
                        if (isRegPro())
                        {
                            rstCab.first();
                            cargarReg();
                        }
                    }
                    else
                    {
                        rstCab.first();
                        cargarReg();
                    }
                }
            }
            catch (java.sql.SQLException e)
            {
                objUti.mostrarMsgErr_F1(this, e);
            }
            catch (Exception e)
            {
                objUti.mostrarMsgErr_F1(this, e);
            }
        }

        public void clickInsertar() //OK
        {
            try
            {
                if (blnHayCam || objTblMod.isDataModelChanged())
                {
                    isRegPro();
                }
                if (rstCab!=null)
                {
                    rstCab.close();
                    stmCab.close();
                    conCab.close();
                    rstCab=null;
                    stmCab=null;
                    conCab=null;
                }
                limpiarFrm();
                txtCod.setEditable(false);
                objTblMod.setModoOperacion(objTblMod.INT_TBL_EDI);
                txtNom.requestFocus();
                //Inicializar las variables que indican cambios.
                objTblMod.setDataModelChanged(false);
                blnHayCam=false;
            }
            catch (java.sql.SQLException e)
            {
                objUti.mostrarMsgErr_F1(this, e);
            }
            catch (Exception e)
            {
                objUti.mostrarMsgErr_F1(this, e);
            }
        }

        public void clickModificar() //OK
        {
            txtCod.setEditable(false);
            objTblMod.setModoOperacion(objTblMod.INT_TBL_EDI);
            //Inicializar las variables que indican cambios.
            objTblMod.setDataModelChanged(false);
            blnHayCam=false;
        }

        public void clickSiguiente() //OK
        {
            try
            {
                if (!rstCab.isLast())
                {
                    if (blnHayCam || objTblMod.isDataModelChanged())
                    {
                        if (isRegPro())
                        {
                            rstCab.next();
                            cargarReg();
                        }
                    }
                    else
                    {
                        rstCab.next();
                        cargarReg();
                    }
                }
            }
            catch (java.sql.SQLException e)
            {
                objUti.mostrarMsgErr_F1(this, e);
            }
            catch (Exception e)
            {
                objUti.mostrarMsgErr_F1(this, e);
            }
        }

        public void clickVisPreliminar() 
        {
        }

        public boolean consultar() //OK
        {
            consultarReg();
            return true;
        }

        public boolean eliminar()
        {
            try
            {
                if (!eliminarReg())
                    return false;
                //Desplazarse al siguiente registro si es posible.
                if (!rstCab.isLast())
                {
                    rstCab.next();
                    cargarReg();
                }
                else
                {
                    objTooBar.setEstadoRegistro("Eliminado");
                    limpiarFrm();
                }
                blnHayCam=false;
            }
            catch (java.sql.SQLException e)
            {
                return true;
            }
            return true;
        }

        public boolean insertar() //OK
        {
            if (!insertarReg())
                return false;
            return true;
        }

        public boolean modificar() //OK
        {
            if (!actualizarReg())
                return false;
            return true;
        }
        
        public boolean cancelar()
        {
            boolean blnRes=true;
            try
            {
                if (blnHayCam || objTblMod.isDataModelChanged())
                {
                    if (objTooBar.getEstado()=='n' || objTooBar.getEstado()=='m')
                    {
                        if (!isRegPro())
                            return false;
                    }
                }
                if (rstCab!=null)
                {
                    rstCab.close();
                    stmCab.close();
                    conCab.close();
                    rstCab=null;
                    stmCab=null;
                    conCab=null;
                }
                objTblMod.clearRowHeaderRaise();
                limpiarFrm();
                //Inicializar las variables que indican cambios.
                objTblMod.setDataModelChanged(false);
                blnHayCam=false;
            }
            catch (java.sql.SQLException e)
            {
                objUti.mostrarMsgErr_F1(this, e);
            }
            catch (Exception e)
            {
                objUti.mostrarMsgErr_F1(this, e);
            }
            return blnRes;
        }
        
        public boolean vistaPreliminar()
        {
            if (objThrGUI==null)
            {
                objThrGUI=new ZafThreadGUI();
                objThrGUI.setIndFunEje(1);
                objThrGUI.start();
            }
            return true;
        }
        
        public boolean aceptar()
        {
            return true;
        }
        
        public boolean imprimir()
        {
            if (objThrGUI==null)
            {
                objThrGUI=new ZafThreadGUI();
                objThrGUI.setIndFunEje(1);
                objThrGUI.start();
            }
            return true;
        }
        
        public boolean beforeInsertar() //OK
        {
            if (!isCamVal())
                return false;
            return true;
        }
        
        public boolean beforeConsultar() //OK
        {
            return true;
        }

        public boolean beforeModificar() //OK
        {
            strAux=objTooBar.getEstadoRegistro();
            if (strAux.equals("Eliminado"))
            {
                mostrarMsgInf("El documento está ELIMINADO.\nNo es posible modificar un documento eliminado.");
                return false;
            }
            if (strAux.equals("Anulado"))
            {
                mostrarMsgInf("El documento está ANULADO.\nNo es posible modificar un documento anulado.");
                return false;
            }
            if (!isCamVal())
                return false;
            return true;
        }

        public boolean beforeEliminar()
        {
//            strAux=objTooBar.getEstadoRegistro();
//            if (strAux.equals("Eliminado"))
//            {
//                mostrarMsgInf("El documento ya está ELIMINADO.\nNo es posible eliminar un documento eliminado.");
//                return false;
//            }
//            if (!strAux.equals("Anulado"))
//            {
//                //Validar que exista el stock.
//                if (!isStkBodSuf())
//                {
//                    mostrarMsgInf("<HTML>Algunos items no tienen stock suficiente para eliminar el documento.<BR>Revise su inventario y vuelva a intentarlo.</HTML>");
//                    return false;
//                }
//            }
            return true;
        }

        public boolean beforeAnular()
        {
            strAux=objTooBar.getEstadoRegistro();
            if (strAux.equals("Eliminado"))
            {
                mostrarMsgInf("El documento está ELIMINADO.\nNo es posible anular un documento eliminado.");
                return false;
            }
            if (strAux.equals("Anulado"))
            {
                mostrarMsgInf("El documento ya está ANULADO.\nNo es posible anular un documento anulado.");
                return false;
            }
            return true;
        }

        public boolean beforeImprimir()
        {
            return true;
        }

        public boolean beforeVistaPreliminar()
        {
            return true;
        }

        public boolean beforeAceptar()
        {
            return true;
        }
        
        public boolean beforeCancelar()
        {
            return true;
        }
        
        public boolean afterInsertar()
        {
            blnHayCam=false;
            objTooBar.setEstado('w');
            consultarRegIns();
            strEstRegRep="I";
//            actualizarValColAux();
            objTblMod.initRowsState();
            blnHayCam=false;
            return true;
        }

        public boolean afterConsultar() //OK
        {
            return true;
        }

        public boolean afterModificar() //OK
        {
            objTblMod.initRowsState();
            blnHayCam=false;
            return true;
        }

        public boolean afterEliminar()
        {
            blnHayCam=false;
            return true;
        }

        public boolean afterAnular()
        {
            return true;
        }

        public boolean afterImprimir()
        {
            return true;
        }

        public boolean afterVistaPreliminar()
        {
            return true;
        }

        public boolean afterAceptar()
        {
            return true;
        }
        
        public boolean afterCancelar()
        {
            return true;
        }
        
    }
    
    /**
     * Esta función determina si los campos son válidos.
     * @return true: Si los campos son válidos.
     * <BR>false: En el caso contrario.
     */
    private boolean isCamVal() //OK
    {
        //Validar el "Nombre".
        if (txtNom.getText().equals(""))
        {
            tabFrm.setSelectedIndex(0);
            mostrarMsgInf("<HTML>El campo <FONT COLOR=\"blue\">Nombre</FONT> es obligatorio.<BR>Escriba un nombre para la forma de pago y vuelva a intentarlo.</HTML>");
            txtNom.requestFocus();
            return false;
        }
        return true;
    }

    /**
     * Esta función muestra un mensaje informativo al usuario. Se podría utilizar
     * para mostrar al usuario un mensaje que indique el campo que es invalido y que
     * debe llenar o corregir.
     */
    private void mostrarMsgInf(String strMsg)
    {
        javax.swing.JOptionPane oppMsg=new javax.swing.JOptionPane();
        String strTit;
        strTit="Mensaje del sistema Zafiro";
        oppMsg.showMessageDialog(this,strMsg,strTit,javax.swing.JOptionPane.INFORMATION_MESSAGE);
    }

    /**
     * Esta función muestra un mensaje "showConfirmDialog". Presenta las opciones
     * Si, No y Cancelar. El usuario es quien determina lo que debe hacer el sistema
     * seleccionando una de las opciones que se presentan.
     */
    private int mostrarMsgCon(String strMsg)
    {
        javax.swing.JOptionPane oppMsg=new javax.swing.JOptionPane();
        String strTit;
        strTit="Mensaje del sistema Zafiro";
        return oppMsg.showConfirmDialog(this,strMsg,strTit,javax.swing.JOptionPane.YES_NO_CANCEL_OPTION,javax.swing.JOptionPane.QUESTION_MESSAGE);
    }

    /**
     * Esta función muestra un mensaje de advertencia al usuario. Se podría utilizar
     * para mostrar al usuario un mensaje que indique que los datos se han cargado
     * con errores y que debe revisar dichos datos.
     */
    private void mostrarMsgAdv(String strMsg)
    {
        javax.swing.JOptionPane oppMsg=new javax.swing.JOptionPane();
        String strTit;
        strTit="Mensaje del sistema Zafiro";
        if (strMsg.equals(""))
            strMsg="<HTML>Este registro tiene <FONT COLOR=\"red\">problemas</FONT>. <BR>Notifíquelo a su administrador del sistema.</HTML>";
        oppMsg.showMessageDialog(this,strMsg,strTit,javax.swing.JOptionPane.WARNING_MESSAGE);
    }

    /**
     * Esta función inserta el registro en la base de datos.
     * @return true: Si se pudo insertar el registro.
     * <BR>false: En el caso contrario.
     */
    private boolean insertarReg() //OK
    {
        boolean blnRes=false;
        try
        {
            con=DriverManager.getConnection(objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos());
            con.setAutoCommit(false);
            if (con!=null)
            {
                if (insertarCab())
                {
                    if (insertarDet())
                    {
                        con.commit();
                        blnRes=true;
                    }
                    else
                        con.rollback();
                }
                else
                    con.rollback();
            }
            con.close();
            con=null;
        }
        catch (java.sql.SQLException e)
        {
            objUti.mostrarMsgErr_F1(this, e);
        }
        catch (Exception e)
        {
            objUti.mostrarMsgErr_F1(this, e);
        }
        return blnRes;
    }

    /**
     * Esta función permite consultar el registro insertado.
     * @return true: Si se pudo consultar el registro.
     * <BR>false: En el caso contrario.
     */
    private boolean consultarRegIns() //OK
    {
        int intCodEmp;
        boolean blnRes=true;
        try
        {
            intCodEmp=objParSis.getCodigoEmpresa();
            conCab=DriverManager.getConnection(objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos());
            if (conCab!=null)
            {
                stmCab=conCab.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
                strSQL="";
                strSQL+="SELECT a1.co_emp, a1.co_forPag";
                strSQL+=" FROM tbm_cabForPag AS a1";
                strSQL+=" WHERE a1.co_emp=" + intCodEmp;
                strSQL+=" AND a1.co_forPag=" + txtCod.getText();
                rstCab=stmCab.executeQuery(strSQL);
                if (rstCab.next())
                {
                    rstCab.last();
                    objTooBar.setMenSis("Se encontró " + rstCab.getRow() + " registro");
                    objTooBar.setPosicionRelativa("1 / 1");
                    objTooBar.setEstadoRegistro("Activo");
                    rstCab.first();
                    strSQLCon=strSQL;
                }
                else
                {
                    mostrarMsgInf("No se ha encontrado ningún registro que cumpla el criterio de búsqueda especificado.");
                    limpiarFrm();
                    objTooBar.setEstado('l');
                    objTooBar.setMenSis("Listo");
                }
            }
        }
        catch (java.sql.SQLException e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        catch (Exception e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        return blnRes;
    }
    
    /**
     * Esta función permite consultar los registros de acuerdo al criterio seleccionado.
     * @return true: Si se pudo consultar los registros.
     * <BR>false: En el caso contrario.
     */
    private boolean consultarReg() //OK
    {
        int intCodEmp;
        boolean blnRes=true;
        try
        {
            intCodEmp=objParSis.getCodigoEmpresa();
            conCab=DriverManager.getConnection(objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos());
            if (conCab!=null)
            {
                stmCab=conCab.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
                strSQL="";
                strSQL+="SELECT a1.co_emp, a1.co_forPag";
                strSQL+=" FROM tbm_cabForPag AS a1";
                strSQL+=" WHERE a1.co_emp=" + intCodEmp;
                strAux=txtCod.getText();
                if (!strAux.equals(""))
                    strSQL+=" AND a1.co_forPag =" + strAux.replaceAll("'", " ") + "";
                strAux=txtNom.getText();
                if (!strAux.equals(""))
                    strSQL+=" AND LOWER(a1.tx_des) LIKE '" + strAux.replaceAll("'", "''").replace('*', '%').toLowerCase() + "'";
                strAux=txaObs1.getText();
                if (!strAux.equals(""))
                    strSQL+=" AND LOWER(a1.tx_obs1) LIKE '" + strAux.replaceAll("'", "''").replace('*', '%').toLowerCase() + "'";
                strSQL+=" ORDER BY a1.co_forPag";
                rstCab=stmCab.executeQuery(strSQL);
                if (rstCab.next())
                {
                    rstCab.last();
                    objTooBar.setMenSis("Se encontraron " + rstCab.getRow() + " registros");
                    rstCab.first();
                    cargarReg();
                    strSQLCon=strSQL;
                }
                else
                {
                    mostrarMsgInf("No se ha encontrado ningún registro que cumpla el criterio de búsqueda especificado.");
                    limpiarFrm();
                    objTooBar.setEstado('l');
                    objTooBar.setMenSis("Listo");
                }
            }
        }
        catch (java.sql.SQLException e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        catch (Exception e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        return blnRes;
    }
    
    /**
     * Esta función actualiza el registro en la base de datos.
     * @return true: Si se pudo actualizar el registro.
     * <BR>false: En el caso contrario.
     */
    private boolean actualizarReg() //OK
    {
        boolean blnRes=false;
        try
        {
            con=DriverManager.getConnection(objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos());
            con.setAutoCommit(false);
            if (con!=null)
            {
                if (actualizarCab())
                {
                    if (eliminarDet())
                    {
                        if (insertarDet())
                        {
                            con.commit();
                            blnRes=true;
                        }
                        else
                            con.rollback();
                    }
                    else
                        con.rollback();
                }
                else
                    con.rollback();
            }
            con.close();
            con=null;
        }
        catch (java.sql.SQLException e)
        {
            objUti.mostrarMsgErr_F1(this, e);
        }
        catch (Exception e)
        {
            objUti.mostrarMsgErr_F1(this, e);
        }
        return blnRes;
    }
    
    /**
     * Esta función elimina el registro de la base de datos.
     * @return true: Si se pudo eliminar el registro.
     * <BR>false: En el caso contrario.
     */
    private boolean eliminarReg()
    {
        boolean blnRes=false;
//        try
//        {
//            con=DriverManager.getConnection(objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos());
//            con.setAutoCommit(false);
//            if (con!=null)
//            {
//                if (eliminarDet())
//                {
////                    if (eliminarCab())
////                    {
////                        if (actualizarTbmInvBod(2))
////                        {
////                            if (actualizarTbmInv())
////                            {
//                                con.commit();
//                                blnRes=true;
////                            }
////                            else
////                                con.rollback();
////                        }
////                        else
////                            con.rollback();
////                    }
////                    else
////                        con.rollback();
//                }
//                else
//                    con.rollback();
//            }
//            con.close();
//            con=null;
//        }
//        catch (java.sql.SQLException e)
//        {
//            objUti.mostrarMsgErr_F1(this, e);
//        }
//        catch (Exception e)
//        {
//            objUti.mostrarMsgErr_F1(this, e);
//        }
        return blnRes;
    }
    
    /**
     * Esta función anula el registro de la base de datos.
     * @return true: Si se pudo anular el registro.
     * <BR>false: En el caso contrario.
     */
    private boolean anularReg()
    {
        boolean blnRes=false;
//        try
//        {
//            con=DriverManager.getConnection(objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos());
//            con.setAutoCommit(false);
//            if (con!=null)
//            {
//                if (anularCab())
//                {
//                    if (actualizarTbmInvBod(3))
//                    {
//                        if (actualizarTbmInv())
//                        {
//                            con.commit();
//                            recostearItm();
//                            blnRes=true;
//                        }
//                        else
//                            con.rollback();
//                    }
//                    else
//                        con.rollback();
//                }
//                else
//                    con.rollback();
//            }
//            con.close();
//            con=null;
//        }
//        catch (java.sql.SQLException e)
//        {
//            objUti.mostrarMsgErr_F1(this, e);
//        }
//        catch (Exception e)
//        {
//            objUti.mostrarMsgErr_F1(this, e);
//        }
        return blnRes;
    }

    /**
     * Esta función permite insertar la cabecera de un registro.
     * @return true: Si se pudo insertar la cabecera del registro.
     * <BR>false: En el caso contrario.
     */
    private boolean insertarCab() //OK
    {
        int intCodUsr, intUltReg, intTipForPag;
        boolean blnRes=true;
        try
        {
            if (con!=null)
            {
                stm=con.createStatement();
                intCodUsr=objParSis.getCodigoUsuario();
                //Obtener el código para "co_forPag".
                strSQL="";
                strSQL+="SELECT MAX(a1.co_forPag)";
                strSQL+=" FROM tbm_cabForPag AS a1";
                strSQL+=" WHERE a1.co_emp=" + objParSis.getCodigoEmpresa();
                intUltReg=objUti.getNumeroRegistro(this, objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos(), strSQL);
                if (intUltReg==-1)
                    return false;
                intUltReg++;
                txtCod.setText("" + intUltReg);
                //Obtener la fecha del servidor.
                datFecAux=objUti.getFechaServidor(objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos(), objParSis.getQueryFechaHoraBaseDatos());
                if (datFecAux==null)
                    return false;
                //Armar la sentencia SQL.
                strSQL="";
                strSQL+="INSERT INTO tbm_cabForPag (co_emp, co_forPag, tx_des, ne_numPag, ne_tipForPag, nd_pes, tx_obs1, st_reg, fe_ing, fe_ultMod, co_usrIng, co_usrMod, st_regRep)";
                strSQL+=" VALUES (";
                strSQL+=objParSis.getCodigoEmpresa(); //co_emp
                strSQL+=", " + intUltReg; //co_forPag
                strSQL+=", " + objUti.codificar(txtNom.getText()); //tx_des
                strSQL+=", " + spiNumPag.getValue(); //ne_numPag
                if (optTipForPagNeg.isSelected())
                    intTipForPag=0;
                else if (optTipForPagCon.isSelected())
                    intTipForPag=1;
                else if (optTipForPagChq.isSelected())
                    intTipForPag=2;
                else if (optTipForPagCre.isSelected())
                    intTipForPag=3;
                else
                    intTipForPag=0;
                strSQL+=", " + intTipForPag; //ne_tipForPag
                switch (intTipForPag)
                {
                    case 0: //Negociación
                        strSQL+=", Null"; //nd_pes
                        break;
                    case 1: //Contado
                        strSQL+=", 0"; //nd_pes
                        break;
                    default: //Cheque y Crédito
                        strSQL+=", " + getPesForPag(); //nd_pes
                }
                strSQL+=", " + objUti.codificar(txaObs1.getText()); //tx_obs1
                strSQL+=", '" + vecEstReg.get(cboEstReg.getSelectedIndex()) + "'"; //st_reg
                strAux=objUti.formatearFecha(datFecAux, objParSis.getFormatoFechaHoraBaseDatos());
                strSQL+=", '" + strAux + "'"; //fe_ing
                strSQL+=", '" + strAux + "'"; //fe_ultMod
                strSQL+=", " + intCodUsr; //co_usrIng
                strSQL+=", " + intCodUsr; //co_usrMod
                strSQL+=", 'I'"; //st_regRep
                strSQL+=")";
                stm.executeUpdate(strSQL);
                stm.close();
                stm=null;
            }
        }
        catch (java.sql.SQLException e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        catch (Exception e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        return blnRes;
    }
    
    /**
     * Esta función permite insertar el detalle de un registro.
     * @return true: Si se pudo insertar el detalle del registro.
     * <BR>false: En el caso contrario.
     */
    private boolean insertarDet() //OK
    {
        int intCodEmp, i;
        String strCodForPag;
        boolean blnRes=true;
        try
        {
            if (con!=null)
            {
                stm=con.createStatement();
                intCodEmp=objParSis.getCodigoEmpresa();
                strCodForPag=txtCod.getText();
                for (i=0;i<objTblMod.getRowCountTrue();i++)
                {
                    //Armar la sentencia SQL.
                    strSQL="";
                    strSQL+="INSERT INTO tbm_detForPag (co_emp, co_forPag, co_reg, ne_diaCre, st_sop, st_regRep)";
                    strSQL+=" VALUES (";
                    strSQL+="" + intCodEmp; //co_emp
                    strSQL+=", " + strCodForPag; //co_forPag
                    strSQL+=", " + (i+1); //co_reg
                    strSQL+=", " + objUti.codificar(objTblMod.getValueAt(i,INT_TBL_DAT_DIA_CRE), 3); //ne_diaCre
                    if (objTblMod.isChecked(i, INT_TBL_DAT_CHK_SOP))
                        strSQL+=", 'S'"; //st_sop
                    else
                        strSQL+=", 'N'"; //st_sop
                    if (strEstRegRep.equals("") || strEstRegRep.equals("I"))
                        strSQL+=", 'I'"; //st_regRep
                    else if (strEstRegRep.equals("P") || strEstRegRep.equals("M"))
                        strSQL+=", 'M'"; //st_regRep
                    strSQL+=")";
                    stm.executeUpdate(strSQL);
                }
                stm.close();
                stm=null;
            }
        }
        catch (java.sql.SQLException e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        catch (Exception e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        return blnRes;
    }
    
    /**
     * Esta función permite cargar el registro seleccionado.
     * @return true: Si se pudo cargar el registro.
     * <BR>false: En el caso contrario.
     */
    private boolean cargarReg() //OK
    {
        boolean blnRes=true;
        try
        {
            if (cargarCabReg())
            {
                cargarDetReg();
            }
            blnHayCam=false;
        }
        catch (Exception e)
        {
            blnRes=false;
        }
        return blnRes;
    }
    
    /**
     * Esta función permite cargar la cabecera del registro seleccionado.
     * @return true: Si se pudo cargar la cabecera del registro.
     * <BR>false: En el caso contrario.
     */
    private boolean cargarCabReg() //OK
    {
        int intPosRel;
        boolean blnRes=true;
        try
        {
            con=DriverManager.getConnection(objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos());
            if (con!=null)
            {
                stm=con.createStatement();
                strSQL="";
                strSQL+="SELECT a1.co_forPag, a1.tx_des, a1.ne_numPag, a1.ne_tipForPag, a1.tx_obs1, a1.st_reg, a1.st_regRep";
                strSQL+=" FROM tbm_cabForPag AS a1";
                strSQL+=" WHERE a1.co_emp=" + rstCab.getString("co_emp");
                strSQL+=" AND a1.co_forPag=" + rstCab.getString("co_forPag");
                rst=stm.executeQuery(strSQL);
                if (rst.next())
                {
                    strAux=rst.getString("co_forPag");
                    txtCod.setText((strAux==null)?"":strAux);
                    strAux=rst.getString("tx_des");
                    txtNom.setText((strAux==null)?"":strAux);
                    spiNumPag.setValue(new Integer(rst.getInt("ne_numPag")));
                    switch (rst.getInt("ne_tipForPag"))
                    {
                        case 0:
                            optTipForPagNeg.setSelected(true);
                            break;
                        case 1:
                            optTipForPagCon.setSelected(true);
                            break;
                        case 2:
                            optTipForPagChq.setSelected(true);
                            break;
                        case 3:
                            optTipForPagCre.setSelected(true);
                            break;
                        default:
                            optTipForPagCon.setSelected(true);
                            break;
                    }
                    strAux=rst.getString("tx_obs1");
                    txaObs1.setText((strAux==null)?"":strAux);
                    //Mostrar el estado del registro.
                    strAux=rst.getString("st_reg");
                    if (!objUti.setItemCombo(cboEstReg, vecEstReg, strAux))
                        blnRes=false;
                    if (strAux.equals("A"))
                        strAux="Activo";
                    else if (strAux.equals("I"))
                        strAux="Anulado";
                    else
                        strAux="Otro";
                    objTooBar.setEstadoRegistro(strAux);
                    strAux=rst.getString("st_regRep");
                    strEstRegRep=(strAux==null)?"":strAux;
                }
                else
                {
                    objTooBar.setEstadoRegistro("Eliminado");
                    limpiarFrm();
                    blnRes=false;
                }
            }
            rst.close();
            stm.close();
            con.close();
            rst=null;
            stm=null;
            con=null;
            //Mostrar la posición relativa del registro.
            intPosRel=rstCab.getRow();
            rstCab.last();
            objTooBar.setPosicionRelativa("" + intPosRel + " / " + rstCab.getRow());
            rstCab.absolute(intPosRel);
        }
        catch (java.sql.SQLException e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        catch (Exception e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        return blnRes;
    }
    
    /**
     * Esta función permite cargar el detalle del registro seleccionado.
     * @return true: Si se pudo cargar el detalle del registro.
     * <BR>false: En el caso contrario.
     */
    private boolean cargarDetReg() //OK
    {
        boolean blnRes=true;
        try
        {
//            objTooBar.setMenSis("Obteniendo datos...");
            con=DriverManager.getConnection(objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos());
            if (con!=null)
            {
                stm=con.createStatement();
                //Armar la sentencia SQL.
                strSQL="";
                strSQL+="SELECT a1.ne_diaCre, a1.st_sop";
                strSQL+=" FROM tbm_detForPag AS a1";
                strSQL+=" WHERE a1.co_emp=" + rstCab.getString("co_emp");
                strSQL+=" AND a1.co_forPag=" + rstCab.getString("co_forPag");
                strSQL+=" ORDER BY a1.co_reg";
                rst=stm.executeQuery(strSQL);
                //Limpiar vector de datos.
                vecDat.clear();
                //Obtener los registros.
//                objTooBar.setMenSis("Cargando datos...");
                while (rst.next())
                {
                    vecReg=new Vector();
                    vecReg.add(INT_TBL_DAT_LIN,"");
                    vecReg.add(INT_TBL_DAT_DIA_CRE,rst.getString("ne_diaCre"));
                    if (rst.getString("st_sop").equals("S"))
                        vecReg.add(INT_TBL_DAT_CHK_SOP,new Boolean(true));
                    else
                        vecReg.add(INT_TBL_DAT_CHK_SOP,null);
                    vecDat.add(vecReg);
                }
                rst.close();
                stm.close();
                con.close();
                rst=null;
                stm=null;
                con=null;
                //Asignar vectores al modelo.
                objTblMod.setData(vecDat);
                tblDat.setModel(objTblMod);
                vecDat.clear();
//                objTooBar.setMenSis("Listo");
            }
        }
        catch (java.sql.SQLException e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        catch (Exception e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        return blnRes;
    }
    
    /**
     * Esta función permite actualizar la cabecera de un registro.
     * @return true: Si se pudo actualizar la cabecera del registro.
     * <BR>false: En el caso contrario.
     */
    private boolean actualizarCab() //OK
    {
        int intTipForPag;
        boolean blnRes=true;
        try
        {
            if (con!=null)
            {
                stm=con.createStatement();
                //Obtener la fecha del servidor.
                datFecAux=objUti.getFechaServidor(objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos(), objParSis.getQueryFechaHoraBaseDatos());
                if (datFecAux==null)
                    return false;
                //Armar la sentencia SQL.
                strSQL="";
                strSQL+="UPDATE tbm_cabForPag";
                strSQL+=" SET tx_des=" + objUti.codificar(txtNom.getText());
                strSQL+=", ne_numPag=" + spiNumPag.getValue();
                if (optTipForPagNeg.isSelected())
                    intTipForPag=0;
                else if (optTipForPagCon.isSelected())
                    intTipForPag=1;
                else if (optTipForPagChq.isSelected())
                    intTipForPag=2;
                else if (optTipForPagCre.isSelected())
                    intTipForPag=3;
                else
                    intTipForPag=0;
                strSQL+=", ne_tipForPag=" + intTipForPag;
                switch (intTipForPag)
                {
                    case 0: //Negociación
                        strSQL+=", nd_pes=Null";
                        break;
                    case 1: //Contado
                        strSQL+=", nd_pes=0";
                        break;
                    default: //Cheque y Crédito
                        strSQL+=", nd_pes=" + getPesForPag();
                }
                strSQL+=", tx_obs1=" + objUti.codificar(txaObs1.getText());
                strSQL+=", st_reg='" + vecEstReg.get(cboEstReg.getSelectedIndex()) + "'";
                strSQL+=", fe_ultMod='" + objUti.formatearFecha(datFecAux, objParSis.getFormatoFechaHoraBaseDatos()) + "'";
                strSQL+=", co_usrMod=" + objParSis.getCodigoUsuario();
                if (!strEstRegRep.equals("I"))
                    strSQL+=", st_regRep='M'";
                strSQL+=" WHERE co_emp=" + rstCab.getString("co_emp");
                strSQL+=" AND co_forPag=" + rstCab.getString("co_forPag");
                stm.executeUpdate(strSQL);
                stm.close();
                stm=null;
                datFecAux=null;
            }
        }
        catch (java.sql.SQLException e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        catch (Exception e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        return blnRes;
    }
    
    /**
     * Esta función permite eliminar la cabecera de un registro.
     * @return true: Si se pudo eliminar la cabecera del registro.
     * <BR>false: En el caso contrario.
     */
    private boolean eliminarCab()
    {
        boolean blnRes=true;
//        try
//        {
//            if (con!=null)
//            {
//                stm=con.createStatement();
//                //Obtener la fecha del servidor.
//                datFecAux=objUti.getFechaServidor(objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos(), objParSis.getQueryFechaHoraBaseDatos());
//                if (datFecAux==null)
//                    return false;
//                //Armar la sentencia SQL.
//                strSQL="";
//                strSQL+="UPDATE tbm_cabMovInv";
//                strSQL+=" SET st_reg='E'";
//                strSQL+=", fe_ultMod='" + objUti.formatearFecha(datFecAux, objParSis.getFormatoFechaHoraBaseDatos()) + "'";
//                strSQL+=", co_usrMod=" + objParSis.getCodigoUsuario();
//                if (!strEstRegRep.equals("I"))
//                    strSQL+=", st_regRep='M'";
//                strSQL+=" WHERE co_emp=" + rstCab.getString("co_emp");
//                strSQL+=" AND co_loc=" + rstCab.getString("co_loc");
//                strSQL+=" AND co_tipDoc=" + rstCab.getString("co_tipDoc");
//                strSQL+=" AND co_doc=" + rstCab.getString("co_doc");
//                stm.executeUpdate(strSQL);
//                stm.close();
//                stm=null;
//                datFecAux=null;
//            }
//        }
//        catch (java.sql.SQLException e)
//        {
//            blnRes=false;
//            objUti.mostrarMsgErr_F1(this, e);
//        }
//        catch (Exception e)
//        {
//            blnRes=false;
//            objUti.mostrarMsgErr_F1(this, e);
//        }
        return blnRes;
    }
    
    /**
     * Esta función permite eliminar el detalle de un registro.
     * @return true: Si se pudo eliminar el detalle del registro.
     * <BR>false: En el caso contrario.
     */
    private boolean eliminarDet() //OK
    {
        boolean blnRes=true;
        try
        {
            if (con!=null)
            {
                stm=con.createStatement();
                //Armar la sentencia SQL.
                strSQL="";
                strSQL+="DELETE FROM tbm_detForPag";
                strSQL+=" WHERE co_emp=" + rstCab.getString("co_emp");
                strSQL+=" AND co_forPag=" + rstCab.getString("co_forPag");
                stm.executeUpdate(strSQL);
                stm.close();
                stm=null;
            }
        }
        catch (java.sql.SQLException e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        catch (Exception e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        return blnRes;
    }
    
    /**
     * Esta función permite anular la cabecera de un registro.
     * @return true: Si se pudo anular la cabecera del registro.
     * <BR>false: En el caso contrario.
     */
    private boolean anularCab()
    {
        boolean blnRes=true;
//        try
//        {
//            if (con!=null)
//            {
//                stm=con.createStatement();
//                //Obtener la fecha del servidor.
//                datFecAux=objUti.getFechaServidor(objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos(), objParSis.getQueryFechaHoraBaseDatos());
//                if (datFecAux==null)
//                    return false;
//                //Armar la sentencia SQL.
//                strSQL="";
//                strSQL+="UPDATE tbm_cabMovInv";
//                strSQL+=" SET st_reg='I'";
//                strSQL+=", fe_ultMod='" + objUti.formatearFecha(datFecAux, objParSis.getFormatoFechaHoraBaseDatos()) + "'";
//                strSQL+=", co_usrMod=" + objParSis.getCodigoUsuario();
//                if (!strEstRegRep.equals("I"))
//                    strSQL+=", st_regRep='M'";
//                strSQL+=" WHERE co_emp=" + rstCab.getString("co_emp");
//                strSQL+=" AND co_loc=" + rstCab.getString("co_loc");
//                strSQL+=" AND co_tipDoc=" + rstCab.getString("co_tipDoc");
//                strSQL+=" AND co_doc=" + rstCab.getString("co_doc");
//                stm.executeUpdate(strSQL);
//                stm.close();
//                stm=null;
//                datFecAux=null;
//            }
//        }
//        catch (java.sql.SQLException e)
//        {
//            blnRes=false;
//            objUti.mostrarMsgErr_F1(this, e);
//        }
//        catch (Exception e)
//        {
//            blnRes=false;
//            objUti.mostrarMsgErr_F1(this, e);
//        }
        return blnRes;
    }
    
    /**
     * Esta función permite limpiar el formulario.
     * @return true: Si se pudo limpiar la ventana sin ningún problema.
     * <BR>false: En el caso contrario.
     */
    private boolean limpiarFrm() //OK
    {
        boolean blnRes=true;
        try
        {
            txtCod.setText("");
            txtNom.setText("");
            spiNumPag.setValue(new Integer(1));
            optTipForPagCon.setSelected(true);
            txaObs1.setText("");
            cboEstReg.setSelectedIndex(0);
            objTblMod.removeAllRows();
            objTblMod.setRowCount(1);
            strEstRegRep="";
        }
        catch (Exception e)
        {
            blnRes=false;
        }
        return blnRes;
    }
    
    /**
     * Esta clase implementa la interface DocumentListener que observa los cambios que
     * se presentan en los objetos de tipo texto. Por ejemplo: JTextField, JTextArea, etc.
     * Se la usa en el sistema para determinar si existe algún cambio que se deba grabar
     * antes de abandonar uno de los modos o desplazarse a otro registro. Por ejemplo: si
     * se ha hecho cambios a un registro y quiere cancelar o moverse a otro registro se
     * presentará un mensaje advirtiendo que si no guarda los cambios los perderá.
     */
    class ZafDocLis implements javax.swing.event.DocumentListener 
    {
        public void changedUpdate(javax.swing.event.DocumentEvent evt) 
        {
            blnHayCam=true;
        }

        public void insertUpdate(javax.swing.event.DocumentEvent evt) 
        {
            blnHayCam=true;
        }

        public void removeUpdate(javax.swing.event.DocumentEvent evt) 
        {
            blnHayCam=true;
        }
    }

    /**
     * Esta función se encarga de agregar el listener "DocumentListener" a los objetos
     * de tipo texto para poder determinar si su contenido a cambiado o no.
     */
    private void agregarDocLis() //OK
    {
        txtCod.getDocument().addDocumentListener(objDocLis);
        txtNom.getDocument().addDocumentListener(objDocLis);
        txaObs1.getDocument().addDocumentListener(objDocLis);
    }   

    /**
     * Esta función se encarga de agregar el listener "DocumentListener" a los objetos
     * de tipo texto para poder determinar si su contenido a cambiado o no.
     */
    private boolean isRegPro() //OK
    {
        boolean blnRes=true;
        strAux="¿Desea guardar los cambios efectuados a éste registro?\n";
        strAux+="Si no guarda los cambios perderá toda la información que no haya guardado.";
        switch (mostrarMsgCon(strAux))
        {
            case 0: //YES_OPTION
                switch (objTooBar.getEstado())
                {
                    case 'n': //Insertar
                        blnRes=objTooBar.beforeInsertar();
                        if (blnRes)
                            blnRes=objTooBar.insertar();
                        break;
                    case 'm': //Modificar
                        blnRes=objTooBar.modificar();
                        break;
                }
                break;
            case 1: //NO_OPTION
                blnHayCam=false;
                blnRes=true;
                break;
            case 2: //CANCEL_OPTION
                blnRes=false;
                break;
        }
        return blnRes;
    }
    
    /**
     * Esta función permite actualizar los valores de las columnas auxiliares.
     * Se utilizan columnas auxiliares para almacenar el valor que tenía la celda
     * antes de ser modificada.
     * @return true: Si se pudo actualizar los valores de las columnas auxiliares.
     * <BR>false: En el caso contrario.
     */
    private boolean actualizarValColAux()
    {
        int i;
        boolean blnRes=true;
//        try
//        {
//            for (i=0;i<objTblMod.getRowCountTrue();i++)
//            {
//                objTblMod.setValueAt(objTblMod.getValueAt(i,INT_TBL_DAT_COD_SIS),i,INT_TBL_DAT_AUX_COD_SIS);
//                objTblMod.setValueAt(objTblMod.getValueAt(i,INT_TBL_DAT_CAN_EGR),i,INT_TBL_DAT_AUX_CAN_EGR);
//                objTblMod.setValueAt(objTblMod.getValueAt(i,INT_TBL_DAT_CAN_ING),i,INT_TBL_DAT_AUX_CAN_ING);
//            }
//        }
//        catch (Exception e)
//        {
//            blnRes=false;
//            objUti.mostrarMsgErr_F1(this, e);
//        }
        return blnRes;
    }

    /**
     * Esta función permite generar el reporte de acuerdo al criterio seleccionado.
     * @param intTipRpt El tipo de reporte a generar.
     * <BR>Puede tomar uno de los siguientes valores:
     * <UL>
     * <LI>0: Impresión directa.
     * <LI>1: Impresión directa (Cuadro de dialogo de impresión).
     * <LI>2: Vista preliminar.
     * </UL>
     * @return true: Si se pudo generar el reporte.
     * <BR>false: En el caso contrario.
     */
    private boolean generarRpt(int intTipRpt)
    {
        String strRutRpt, strNomRpt, strFecHorSer;
        int i, intNumTotRpt;
        boolean blnRes=true;
        try
        {
//            objRptSis.cargarListadoReportes(conCab);
//            objRptSis.show();
//            if (objRptSis.getOpcionSeleccionada()==objRptSis.INT_OPC_ACE)
//            {
//                //Obtener la fecha y hora del servidor.
//                datFecAux=objUti.getFechaServidor(objParSis.getStringConexion(), objParSis.getUsuarioBaseDatos(), objParSis.getClaveBaseDatos(), objParSis.getQueryFechaHoraBaseDatos());
//                if (datFecAux==null)
//                    return false;
//                strFecHorSer=objUti.formatearFecha(datFecAux, "dd/MMM/yyyy HH:mm:ss");
//                datFecAux=null;
//                intNumTotRpt=objRptSis.getNumeroTotalReportes();
//                for (i=0;i<intNumTotRpt;i++)
//                {
//                    if (objRptSis.isReporteSeleccionado(i))
//                    {
//                        switch (Integer.parseInt(objRptSis.getCodigoReporte(i)))
//                        {
//                            case 19:
//                            default:
//                                strRutRpt=objRptSis.getRutaReporte(i);
//                                strNomRpt=objRptSis.getNombreReporte(i);
//                                //Inicializar los parametros que se van a pasar al reporte.
//                                java.util.Map mapPar=new java.util.HashMap();
//                                mapPar.put("SUBREPORT_DIR", strRutRpt);
//                                mapPar.put("co_emp", Short.valueOf(rstCab.getString("co_emp")));
//                                mapPar.put("co_loc", Short.valueOf(rstCab.getString("co_loc")));
//                                mapPar.put("co_tipDoc", Short.valueOf(rstCab.getString("co_tipDoc")));
//                                mapPar.put("co_doc", Integer.valueOf(rstCab.getString("co_doc")));
//                                mapPar.put("strCamAudRpt", this.getClass().getName() + "   " + strNomRpt + "   " + objParSis.getNombreUsuario() + "   " + strFecHorSer);
//                                objRptSis.generarReporte(strRutRpt, strNomRpt, mapPar, intTipRpt);
//                                break;
//                        }
//                    }
//                }
//            }
        }
        catch (Exception e)
        {
            blnRes=false;
            objUti.mostrarMsgErr_F1(this, e);
        }
        return blnRes;
    }

    /**
     * Esta función obtiene el peso de la forma de pago.
     * Es decir, el valor que se debe almacenar en el campo "nd_pes".
     * @return El peso de la forma de pago.
     * <BR>Nota.- Si se produce algún error se <I>null</I>.
     */
    private BigDecimal getPesForPag()
    {
        int intMaxDiaCre, intTipForPag, intNumPag, intSumDiaCre, i;
        BigDecimal bgdRes=null;
        try
        {
            intMaxDiaCre=Integer.parseInt(objTblMod.getValueAt(objTblMod.getRowCountTrue()-1, INT_TBL_DAT_DIA_CRE).toString());
            if (optTipForPagNeg.isSelected())
                intTipForPag=0;
            else if (optTipForPagCon.isSelected())
                intTipForPag=1;
            else if (optTipForPagChq.isSelected())
                intTipForPag=2;
            else if (optTipForPagCre.isSelected())
                intTipForPag=3;
            else
                intTipForPag=0;
            intNumPag=Integer.parseInt(spiNumPag.getValue().toString());
            intSumDiaCre=0;
            for (i=0; i<objTblMod.getRowCountTrue(); i++)
                intSumDiaCre+=Integer.parseInt(objTblMod.getValueAt(i, INT_TBL_DAT_DIA_CRE).toString());
            bgdRes=new BigDecimal(intMaxDiaCre).add(new BigDecimal(intTipForPag)).add(new BigDecimal(intTipForPag).divide(new BigDecimal(intNumPag), objParSis.getDecimalesBaseDatos(), BigDecimal.ROUND_HALF_UP)).add(new BigDecimal(intSumDiaCre).divide(new BigDecimal(intMaxDiaCre*intNumPag), objParSis.getDecimalesBaseDatos(), BigDecimal.ROUND_HALF_UP));
        }
        catch (Exception e)
        {
            bgdRes=null;
            objUti.mostrarMsgErr_F1(this, e);
        }
        return bgdRes;
    }
    
    /**
     * Esta clase crea un hilo que permite manipular la interface gráfica de usuario (GUI).
     * Por ejemplo: se la puede utilizar para cargar los datos en un JTable donde la idea
     * es mostrar al usuario lo que está ocurriendo internamente. Es decir a medida que se
     * llevan a cabo los procesos se podría presentar mensajes informativos en un JLabel e
     * ir incrementando un JProgressBar con lo cual el usuario estaría informado en todo
     * momento de lo que ocurre. Si se desea hacer ésto es necesario utilizar ésta clase
     * ya que si no sólo se apreciaría los cambios cuando ha terminado todo el proceso.
     */
    private class ZafThreadGUI extends Thread
    {
        private int intIndFun;
        
        public ZafThreadGUI()
        {
            intIndFun=0;
        }
        
        public void run()
        {
            switch (intIndFun)
            {
                case 0: //Botón "Imprimir".
                    objTooBar.setEnabledImprimir(false);
                    generarRpt(1);
                    objTooBar.setEnabledImprimir(true);
                    break;
                case 1: //Botón "Vista Preliminar".
                    objTooBar.setEnabledVistaPreliminar(false);
                    generarRpt(2);
                    objTooBar.setEnabledVistaPreliminar(true);
                    break;
            }
            objThrGUI=null;
        }
        
        /**
         * Esta función establece el indice de la función a ejecutar. En la clase Thread
         * se pueden ejecutar diferentes funciones. Esta función sirve para determinar
         * la función que debe ejecutar el Thread.
         * @param indice El indice de la función a ejecutar.
         */
        public void setIndFunEje(int indice)
        {
            intIndFun=indice;
        }
    }

    /**
     * Esta clase hereda de la clase MouseMotionAdapter que permite manejar eventos de
     * del mouse (mover el mouse; arrastrar y soltar).
     * Se la usa en el sistema para mostrar el ToolTipText adecuado en la cabecera de
     * las columnas. Es necesario hacerlo porque el ancho de las columnas a veces
     * resulta muy corto para mostrar leyendas que requieren más espacio.
     */
    private class ZafMouMotAda extends java.awt.event.MouseMotionAdapter
    {
        public void mouseMoved(java.awt.event.MouseEvent evt)
        {
            int intCol=tblDat.columnAtPoint(evt.getPoint());
            String strMsg="";
            switch (intCol)
            {
                case INT_TBL_DAT_DIA_CRE:
                    strMsg="Días de crédito (Plazo)";
                    break;
                case INT_TBL_DAT_CHK_SOP:
                    strMsg="¿Es necesario soporte?";
                    break;
                default:
                    strMsg="";
                    break;
            }
            tblDat.getTableHeader().setToolTipText(strMsg);
        }
    }

}